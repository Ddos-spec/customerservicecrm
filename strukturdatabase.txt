CREATE TABLE "public"."audit_logs" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NULL,
  "actor_user_id" UUID NULL,
  "action" TEXT NOT NULL,
  "target_type" TEXT NULL,
  "target_id" UUID NULL,
  "ip" TEXT NULL,
  "user_agent" TEXT NULL,
  "metadata" JSONB NOT NULL DEFAULT '{}'::jsonb ,
  "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now() ,
  CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id")
);
CREATE TABLE "public"."contact_identifiers" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NOT NULL,
  "contact_id" UUID NOT NULL,
  "kind" TEXT NOT NULL,
  "value" TEXT NOT NULL,
  "is_primary" BOOLEAN NOT NULL DEFAULT true ,
  "active" BOOLEAN NOT NULL DEFAULT true ,
  "verified_at" TIMESTAMP WITH TIME ZONE NULL,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  CONSTRAINT "contact_identifiers_pkey" PRIMARY KEY ("id"),
  CONSTRAINT "contact_identifiers_tenant_id_kind_value_key" UNIQUE ("tenant_id", "kind", "value")
);
CREATE TABLE "public"."contacts" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NOT NULL,
  "display_name" TEXT NULL,
  "push_name" TEXT NULL,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  CONSTRAINT "contacts_pkey" PRIMARY KEY ("id")
);
CREATE TABLE "public"."conversation_events" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NOT NULL,
  "conversation_id" UUID NOT NULL,
  "event_type" TEXT NOT NULL,
  "reason" TEXT NULL,
  "payload" JSONB NOT NULL DEFAULT '{}'::jsonb ,
  "created_by_user_id" UUID NULL,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  CONSTRAINT "conversation_events_pkey" PRIMARY KEY ("id")
);
CREATE TABLE "public"."conversations" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NOT NULL,
  "channel" TEXT NOT NULL DEFAULT 'whatsapp'::text ,
  "contact_id" UUID NOT NULL,
  "status" VARCHAR(30) NOT NULL DEFAULT 'open'::character varying ,
  "assigned_user_id" UUID NULL,
  "escalated_at" TIMESTAMP WITH TIME ZONE NULL,
  "last_message_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  CONSTRAINT "conversations_pkey" PRIMARY KEY ("id")
);
CREATE TABLE "public"."message_attachments" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NOT NULL,
  "message_id" UUID NOT NULL,
  "mime_type" TEXT NOT NULL,
  "size_bytes" BIGINT NULL,
  "duration_ms" INTEGER NULL,
  "storage_provider" TEXT NOT NULL DEFAULT 's3'::text ,
  "storage_key" TEXT NOT NULL,
  "thumbnail_key" TEXT NULL,
  "sha256" TEXT NULL,
  "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now() ,
  CONSTRAINT "message_attachments_pkey" PRIMARY KEY ("id")
);
CREATE TABLE "public"."messages" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "ticket_id" UUID NOT NULL,
  "sender_type" VARCHAR(20) NOT NULL,
  "message_text" TEXT NULL,
  "file_url" TEXT NULL,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  CONSTRAINT "messages_pkey" PRIMARY KEY ("id")
);
CREATE TABLE "public"."outlet_channels" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "outlet_id" INTEGER NOT NULL,
  "channel" VARCHAR(50) NULL DEFAULT 'whatsapp'::character varying ,
  "channel_identifier" VARCHAR(255) NULL,
  "created_at" TIMESTAMP NULL DEFAULT now() ,
  CONSTRAINT "outlet_channels_pkey" PRIMARY KEY ("id")
);
CREATE TABLE "public"."system_settings" ( 
  "key" TEXT NOT NULL,
  "value" TEXT NOT NULL,
  CONSTRAINT "system_settings_pkey" PRIMARY KEY ("key")
);
CREATE TABLE "public"."tenant_integrations" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NOT NULL,
  "provider" TEXT NOT NULL DEFAULT 'baileys'::text ,
  "session_key" TEXT NULL,
  "last_seen_at" TIMESTAMP WITH TIME ZONE NULL,
  "is_connected" BOOLEAN NOT NULL DEFAULT false ,
  "meta" JSONB NOT NULL DEFAULT '{}'::jsonb ,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  CONSTRAINT "tenant_integrations_pkey" PRIMARY KEY ("id"),
  CONSTRAINT "tenant_integrations_tenant_id_key" UNIQUE ("tenant_id")
);
CREATE TABLE "public"."tenant_members" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NOT NULL,
  "user_id" UUID NOT NULL,
  "display_name" TEXT NULL,
  "is_tenant_admin" BOOLEAN NOT NULL DEFAULT false ,
  "status" VARCHAR(20) NOT NULL DEFAULT 'active'::character varying ,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  CONSTRAINT "tenant_members_pkey" PRIMARY KEY ("id"),
  CONSTRAINT "tenant_members_tenant_id_user_id_key" UNIQUE ("tenant_id", "user_id")
);
CREATE TABLE "public"."tenant_webhooks" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NOT NULL,
  "url" TEXT NOT NULL,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  CONSTRAINT "tenant_webhooks_pkey" PRIMARY KEY ("id"),
  CONSTRAINT "tenant_webhooks_tenant_id_url_key" UNIQUE ("tenant_id", "url")
);
CREATE TABLE "public"."tenants" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "company_name" TEXT NOT NULL,
  "status" VARCHAR(20) NULL DEFAULT 'active'::character varying ,
  "session_id" TEXT NULL,
  "max_active_members" INTEGER NULL DEFAULT 100 ,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  CONSTRAINT "tenants_pkey" PRIMARY KEY ("id"),
  CONSTRAINT "tenants_session_id_key" UNIQUE ("session_id")
);
CREATE TABLE "public"."tickets" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NOT NULL,
  "customer_name" TEXT NULL,
  "customer_contact" TEXT NULL,
  "status" VARCHAR(50) NULL DEFAULT 'open'::character varying ,
  "assigned_agent_id" UUID NULL,
  "internal_notes" TEXT NULL,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  "updated_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  CONSTRAINT "tickets_pkey" PRIMARY KEY ("id")
);
CREATE TABLE "public"."user_invites" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NOT NULL,
  "name" TEXT NOT NULL,
  "email" TEXT NOT NULL,
  "role" VARCHAR(20) NOT NULL DEFAULT 'agent'::character varying ,
  "token" TEXT NOT NULL,
  "status" VARCHAR(20) NOT NULL DEFAULT 'pending'::character varying ,
  "created_by" UUID NULL,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  "expires_at" TIMESTAMP WITH TIME ZONE NULL,
  "phone_number" TEXT NULL,
  CONSTRAINT "user_invites_pkey" PRIMARY KEY ("id"),
  CONSTRAINT "user_invites_token_key" UNIQUE ("token")
);
CREATE TABLE "public"."users" ( 
  "id" UUID NOT NULL DEFAULT gen_random_uuid() ,
  "tenant_id" UUID NULL,
  "name" TEXT NOT NULL,
  "email" TEXT NOT NULL,
  "password_hash" TEXT NOT NULL,
  "role" VARCHAR(20) NOT NULL,
  "status" VARCHAR(20) NULL DEFAULT 'active'::character varying ,
  "created_at" TIMESTAMP WITH TIME ZONE NULL DEFAULT now() ,
  "phone_number" TEXT NULL,
  CONSTRAINT "users_pkey" PRIMARY KEY ("id"),
  CONSTRAINT "users_email_key" UNIQUE ("email")
);
CREATE TABLE "public"."whatsmeow_app_state_mutation_macs" ( 
  "jid" TEXT NOT NULL,
  "name" TEXT NOT NULL,
  "version" BIGINT NOT NULL,
  "index_mac" BYTEA NOT NULL,
  "value_mac" BYTEA NOT NULL,
  CONSTRAINT "whatsmeow_app_state_mutation_macs_pkey" PRIMARY KEY ("jid", "name", "version", "index_mac")
);
CREATE TABLE "public"."whatsmeow_app_state_sync_keys" ( 
  "jid" TEXT NOT NULL,
  "key_id" BYTEA NOT NULL,
  "key_data" BYTEA NOT NULL,
  "timestamp" BIGINT NOT NULL,
  "fingerprint" BYTEA NOT NULL,
  CONSTRAINT "whatsmeow_app_state_sync_keys_pkey" PRIMARY KEY ("jid", "key_id")
);
CREATE TABLE "public"."whatsmeow_app_state_version" ( 
  "jid" TEXT NOT NULL,
  "name" TEXT NOT NULL,
  "version" BIGINT NOT NULL,
  "hash" BYTEA NOT NULL,
  CONSTRAINT "whatsmeow_app_state_version_pkey" PRIMARY KEY ("jid", "name")
);
CREATE TABLE "public"."whatsmeow_chat_settings" ( 
  "our_jid" TEXT NOT NULL,
  "chat_jid" TEXT NOT NULL,
  "muted_until" BIGINT NOT NULL DEFAULT 0 ,
  "pinned" BOOLEAN NOT NULL DEFAULT false ,
  "archived" BOOLEAN NOT NULL DEFAULT false ,
  CONSTRAINT "whatsmeow_chat_settings_pkey" PRIMARY KEY ("our_jid", "chat_jid")
);
CREATE TABLE "public"."whatsmeow_contacts" ( 
  "our_jid" TEXT NOT NULL,
  "their_jid" TEXT NOT NULL,
  "first_name" TEXT NULL,
  "full_name" TEXT NULL,
  "push_name" TEXT NULL,
  "business_name" TEXT NULL,
  "redacted_phone" TEXT NULL,
  CONSTRAINT "whatsmeow_contacts_pkey" PRIMARY KEY ("our_jid", "their_jid")
);
CREATE TABLE "public"."whatsmeow_device" ( 
  "jid" TEXT NOT NULL,
  "lid" TEXT NULL,
  "facebook_uuid" UUID NULL,
  "registration_id" BIGINT NOT NULL,
  "noise_key" BYTEA NOT NULL,
  "identity_key" BYTEA NOT NULL,
  "signed_pre_key" BYTEA NOT NULL,
  "signed_pre_key_id" INTEGER NOT NULL,
  "signed_pre_key_sig" BYTEA NOT NULL,
  "adv_key" BYTEA NOT NULL,
  "adv_details" BYTEA NOT NULL,
  "adv_account_sig" BYTEA NOT NULL,
  "adv_account_sig_key" BYTEA NOT NULL,
  "adv_device_sig" BYTEA NOT NULL,
  "platform" TEXT NOT NULL DEFAULT ''::text ,
  "business_name" TEXT NOT NULL DEFAULT ''::text ,
  "push_name" TEXT NOT NULL DEFAULT ''::text ,
  "lid_migration_ts" BIGINT NOT NULL DEFAULT 0 ,
  CONSTRAINT "whatsmeow_device_pkey" PRIMARY KEY ("jid")
);
CREATE TABLE "public"."whatsmeow_event_buffer" ( 
  "our_jid" TEXT NOT NULL,
  "ciphertext_hash" BYTEA NOT NULL,
  "plaintext" BYTEA NULL,
  "server_timestamp" BIGINT NOT NULL,
  "insert_timestamp" BIGINT NOT NULL,
  CONSTRAINT "whatsmeow_event_buffer_pkey" PRIMARY KEY ("our_jid", "ciphertext_hash")
);
CREATE TABLE "public"."whatsmeow_identity_keys" ( 
  "our_jid" TEXT NOT NULL,
  "their_id" TEXT NOT NULL,
  "identity" BYTEA NOT NULL,
  CONSTRAINT "whatsmeow_identity_keys_pkey" PRIMARY KEY ("our_jid", "their_id")
);
CREATE TABLE "public"."whatsmeow_lid_map" ( 
  "lid" TEXT NOT NULL,
  "pn" TEXT NOT NULL,
  CONSTRAINT "whatsmeow_lid_map_pkey" PRIMARY KEY ("lid"),
  CONSTRAINT "whatsmeow_lid_map_pn_key" UNIQUE ("pn")
);
CREATE TABLE "public"."whatsmeow_message_secrets" ( 
  "our_jid" TEXT NOT NULL,
  "chat_jid" TEXT NOT NULL,
  "sender_jid" TEXT NOT NULL,
  "message_id" TEXT NOT NULL,
  "key" BYTEA NOT NULL,
  CONSTRAINT "whatsmeow_message_secrets_pkey" PRIMARY KEY ("our_jid", "chat_jid", "sender_jid", "message_id")
);
CREATE TABLE "public"."whatsmeow_pre_keys" ( 
  "jid" TEXT NOT NULL,
  "key_id" INTEGER NOT NULL,
  "key" BYTEA NOT NULL,
  "uploaded" BOOLEAN NOT NULL,
  CONSTRAINT "whatsmeow_pre_keys_pkey" PRIMARY KEY ("jid", "key_id")
);
CREATE TABLE "public"."whatsmeow_privacy_tokens" ( 
  "our_jid" TEXT NOT NULL,
  "their_jid" TEXT NOT NULL,
  "token" BYTEA NOT NULL,
  "timestamp" BIGINT NOT NULL,
  CONSTRAINT "whatsmeow_privacy_tokens_pkey" PRIMARY KEY ("our_jid", "their_jid")
);
CREATE TABLE "public"."whatsmeow_sender_keys" ( 
  "our_jid" TEXT NOT NULL,
  "chat_id" TEXT NOT NULL,
  "sender_id" TEXT NOT NULL,
  "sender_key" BYTEA NOT NULL,
  CONSTRAINT "whatsmeow_sender_keys_pkey" PRIMARY KEY ("our_jid", "chat_id", "sender_id")
);
CREATE TABLE "public"."whatsmeow_sessions" ( 
  "our_jid" TEXT NOT NULL,
  "their_id" TEXT NOT NULL,
  "session" BYTEA NULL,
  CONSTRAINT "whatsmeow_sessions_pkey" PRIMARY KEY ("our_jid", "their_id")
);
CREATE TABLE "public"."whatsmeow_version" ( 
  "version" INTEGER NULL,
  "compat" INTEGER NULL
);
CREATE INDEX "idx_audit_actor_time" 
ON "public"."audit_logs" (
  "actor_user_id" ASC,
  "created_at" DESC
);
CREATE INDEX "idx_audit_tenant_time" 
ON "public"."audit_logs" (
  "tenant_id" ASC,
  "created_at" DESC
);
CREATE INDEX "idx_contact_identifiers_contact" 
ON "public"."contact_identifiers" (
  "contact_id" ASC
);
CREATE INDEX "idx_contacts_tenant" 
ON "public"."contacts" (
  "tenant_id" ASC
);
CREATE INDEX "idx_events_conv_time" 
ON "public"."conversation_events" (
  "conversation_id" ASC,
  "created_at" DESC
);
CREATE INDEX "idx_conversations_tenant_status" 
ON "public"."conversations" (
  "tenant_id" ASC,
  "status" ASC
);
CREATE INDEX "idx_conversations_tenant_lastmsg" 
ON "public"."conversations" (
  "tenant_id" ASC,
  "last_message_at" DESC
);
CREATE INDEX "idx_attachments_message" 
ON "public"."message_attachments" (
  "message_id" ASC
);
CREATE INDEX "idx_messages_created_at" 
ON "public"."messages" (
  "created_at" ASC
);
CREATE INDEX "idx_messages_ticket_id" 
ON "public"."messages" (
  "ticket_id" ASC
);
CREATE INDEX "idx_outlet_channels_outlet_id" 
ON "public"."outlet_channels" (
  "outlet_id" ASC
);
CREATE INDEX "idx_tenant_members_user" 
ON "public"."tenant_members" (
  "user_id" ASC
);
CREATE INDEX "idx_tenant_members_tenant" 
ON "public"."tenant_members" (
  "tenant_id" ASC
);
CREATE INDEX "tenant_webhooks_tenant_id_idx" 
ON "public"."tenant_webhooks" (
  "tenant_id" ASC
);
CREATE INDEX "idx_tickets_tenant_id" 
ON "public"."tickets" (
  "tenant_id" ASC
);
CREATE INDEX "idx_tickets_assigned_agent" 
ON "public"."tickets" (
  "assigned_agent_id" ASC
);
CREATE INDEX "user_invites_status_idx" 
ON "public"."user_invites" (
  "status" ASC
);
CREATE INDEX "user_invites_tenant_id_idx" 
ON "public"."user_invites" (
  "tenant_id" ASC
);
CREATE INDEX "user_invites_email_idx" 
ON "public"."user_invites" (
  "email" ASC
);
CREATE INDEX "idx_users_tenant_role_status" 
ON "public"."users" (
  "tenant_id" ASC,
  "role" ASC,
  "status" ASC
);
ALTER TABLE "public"."contact_identifiers" ADD CONSTRAINT "contact_identifiers_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."contact_identifiers" ADD CONSTRAINT "contact_identifiers_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."contacts" ADD CONSTRAINT "contacts_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."conversation_events" ADD CONSTRAINT "conversation_events_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."conversation_events" ADD CONSTRAINT "conversation_events_conversation_id_fkey" FOREIGN KEY ("conversation_id") REFERENCES "public"."conversations" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."conversation_events" ADD CONSTRAINT "conversation_events_created_by_user_id_fkey" FOREIGN KEY ("created_by_user_id") REFERENCES "public"."users" ("id") ON DELETE SET NULL ON UPDATE NO ACTION;
ALTER TABLE "public"."conversations" ADD CONSTRAINT "conversations_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."conversations" ADD CONSTRAINT "conversations_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION;
ALTER TABLE "public"."conversations" ADD CONSTRAINT "conversations_assigned_user_id_fkey" FOREIGN KEY ("assigned_user_id") REFERENCES "public"."users" ("id") ON DELETE SET NULL ON UPDATE NO ACTION;
ALTER TABLE "public"."messages" ADD CONSTRAINT "messages_ticket_id_fkey" FOREIGN KEY ("ticket_id") REFERENCES "public"."tickets" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."tenant_integrations" ADD CONSTRAINT "tenant_integrations_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."tenant_members" ADD CONSTRAINT "tenant_members_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."tenant_members" ADD CONSTRAINT "tenant_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."tenant_webhooks" ADD CONSTRAINT "tenant_webhooks_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."tickets" ADD CONSTRAINT "tickets_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."tickets" ADD CONSTRAINT "tickets_assigned_agent_id_fkey" FOREIGN KEY ("assigned_agent_id") REFERENCES "public"."users" ("id") ON DELETE SET NULL ON UPDATE NO ACTION;
ALTER TABLE "public"."user_invites" ADD CONSTRAINT "user_invites_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users" ("id") ON DELETE SET NULL ON UPDATE NO ACTION;
ALTER TABLE "public"."whatsmeow_app_state_mutation_macs" ADD CONSTRAINT "whatsmeow_app_state_mutation_macs_jid_name_fkey" FOREIGN KEY ("jid", "name") REFERENCES "public"."whatsmeow_app_state_version" ("jid", "name") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "public"."whatsmeow_app_state_sync_keys" ADD CONSTRAINT "whatsmeow_app_state_sync_keys_jid_fkey" FOREIGN KEY ("jid") REFERENCES "public"."whatsmeow_device" ("jid") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "public"."whatsmeow_app_state_version" ADD CONSTRAINT "whatsmeow_app_state_version_jid_fkey" FOREIGN KEY ("jid") REFERENCES "public"."whatsmeow_device" ("jid") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "public"."whatsmeow_chat_settings" ADD CONSTRAINT "whatsmeow_chat_settings_our_jid_fkey" FOREIGN KEY ("our_jid") REFERENCES "public"."whatsmeow_device" ("jid") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "public"."whatsmeow_contacts" ADD CONSTRAINT "whatsmeow_contacts_our_jid_fkey" FOREIGN KEY ("our_jid") REFERENCES "public"."whatsmeow_device" ("jid") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "public"."whatsmeow_event_buffer" ADD CONSTRAINT "whatsmeow_event_buffer_our_jid_fkey" FOREIGN KEY ("our_jid") REFERENCES "public"."whatsmeow_device" ("jid") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "public"."whatsmeow_identity_keys" ADD CONSTRAINT "whatsmeow_identity_keys_our_jid_fkey" FOREIGN KEY ("our_jid") REFERENCES "public"."whatsmeow_device" ("jid") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "public"."whatsmeow_message_secrets" ADD CONSTRAINT "whatsmeow_message_secrets_our_jid_fkey" FOREIGN KEY ("our_jid") REFERENCES "public"."whatsmeow_device" ("jid") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "public"."whatsmeow_pre_keys" ADD CONSTRAINT "whatsmeow_pre_keys_jid_fkey" FOREIGN KEY ("jid") REFERENCES "public"."whatsmeow_device" ("jid") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "public"."whatsmeow_sender_keys" ADD CONSTRAINT "whatsmeow_sender_keys_our_jid_fkey" FOREIGN KEY ("our_jid") REFERENCES "public"."whatsmeow_device" ("jid") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "public"."whatsmeow_sessions" ADD CONSTRAINT "whatsmeow_sessions_our_jid_fkey" FOREIGN KEY ("our_jid") REFERENCES "public"."whatsmeow_device" ("jid") ON DELETE CASCADE ON UPDATE CASCADE;
CREATE FUNCTION "public"."app_set_context"(IN p_tenant UUID, IN p_user UUID) RETURNS VOID LANGUAGE PLPGSQL
AS
$$

BEGIN
  PERFORM set_config('app.current_tenant', p_tenant::text, true);
  PERFORM set_config('app.current_user',  p_user::text,  true);
END 
$$;
CREATE FUNCTION "public"."armor"() RETURNS TEXT|TEXT LANGUAGE C
AS
$$
pg_armor
$$;
CREATE FUNCTION "public"."assert_contact_identifier_tenant"() RETURNS TRIGGER LANGUAGE PLPGSQL
AS
$$

DECLARE
  v_tenant uuid;
BEGIN
  SELECT tenant_id INTO v_tenant FROM public.contacts WHERE id = NEW.contact_id;

  IF v_tenant IS NULL THEN
    RAISE EXCEPTION 'contact_id % not found', NEW.contact_id;
  END IF;

  IF NEW.tenant_id <> v_tenant THEN
    RAISE EXCEPTION 'tenant mismatch: contact_identifiers.tenant_id % <> contacts.tenant_id %', NEW.tenant_id, v_tenant;
  END IF;

  RETURN NEW;
END 
$$;
CREATE FUNCTION "public"."assert_conversation_tenant"() RETURNS TRIGGER LANGUAGE PLPGSQL
AS
$$

DECLARE
  v_tenant uuid;
BEGIN
  SELECT tenant_id INTO v_tenant FROM public.contacts WHERE id = NEW.contact_id;

  IF v_tenant IS NULL THEN
    RAISE EXCEPTION 'contact_id % not found', NEW.contact_id;
  END IF;

  IF NEW.tenant_id <> v_tenant THEN
    RAISE EXCEPTION 'tenant mismatch: conversations.tenant_id % <> contacts.tenant_id %', NEW.tenant_id, v_tenant;
  END IF;

  RETURN NEW;
END 
$$;
CREATE FUNCTION "public"."assert_message_tenant"() RETURNS TRIGGER LANGUAGE PLPGSQL
AS
$$

DECLARE
  v_tenant uuid;
BEGIN
  SELECT tenant_id INTO v_tenant FROM public.conversations WHERE id = NEW.conversation_id;

  IF v_tenant IS NULL THEN
    RAISE EXCEPTION 'conversation_id % not found', NEW.conversation_id;
  END IF;

  IF NEW.tenant_id <> v_tenant THEN
    RAISE EXCEPTION 'tenant mismatch: messages.tenant_id % <> conversations.tenant_id %', NEW.tenant_id, v_tenant;
  END IF;

  RETURN NEW;
END 
$$;
CREATE FUNCTION "public"."assign_conversation"(IN p_tenant UUID, IN p_conversation UUID, IN p_user UUID, IN p_by_user UUID) RETURNS VOID LANGUAGE PLPGSQL
AS
$$

BEGIN
  UPDATE conversations
  SET assigned_user_id = p_user
  WHERE id = p_conversation AND tenant_id = p_tenant;

  INSERT INTO conversation_events (tenant_id, conversation_id, event_type, payload, created_by_user_id)
  VALUES (p_tenant, p_conversation, 'assigned', jsonb_build_object('assigned_user_id', p_user), p_by_user);
END 
$$;
CREATE FUNCTION "public"."close_conversation"(IN p_tenant UUID, IN p_conversation UUID, IN p_by_user UUID) RETURNS VOID LANGUAGE PLPGSQL
AS
$$

BEGIN
  UPDATE conversations
  SET status = 'closed'
  WHERE id = p_conversation AND tenant_id = p_tenant;

  INSERT INTO conversation_events (tenant_id, conversation_id, event_type, created_by_user_id)
  VALUES (p_tenant, p_conversation, 'closed', p_by_user);
END 
$$;
CREATE FUNCTION "public"."crypt"() RETURNS TEXT LANGUAGE C
AS
$$
pg_crypt
$$;
CREATE FUNCTION "public"."dearmor"() RETURNS BYTEA LANGUAGE C
AS
$$
pg_dearmor
$$;
CREATE FUNCTION "public"."decrypt"() RETURNS BYTEA LANGUAGE C
AS
$$
pg_decrypt
$$;
CREATE FUNCTION "public"."decrypt_iv"() RETURNS BYTEA LANGUAGE C
AS
$$
pg_decrypt_iv
$$;
CREATE FUNCTION "public"."digest"() RETURNS BYTEA|BYTEA LANGUAGE C
AS
$$
pg_digest
$$;
CREATE FUNCTION "public"."encrypt"() RETURNS BYTEA LANGUAGE C
AS
$$
pg_encrypt
$$;
CREATE FUNCTION "public"."encrypt_iv"() RETURNS BYTEA LANGUAGE C
AS
$$
pg_encrypt_iv
$$;
CREATE FUNCTION "public"."enforce_seat_limit"() RETURNS TRIGGER LANGUAGE PLPGSQL
AS
$$

DECLARE
  v_limit int;
  v_active int;
BEGIN
  SELECT max_active_members INTO v_limit
  FROM public.tenants
  WHERE id = NEW.tenant_id;
  
  IF v_limit IS NULL THEN
    RETURN NEW;
  END IF;
  
  IF TG_OP = 'UPDATE' THEN
    SELECT COUNT(*) INTO v_active
    FROM public.tenant_members
    WHERE tenant_id = NEW.tenant_id
      AND status = 'active'
      AND id <> NEW.id;
  ELSE
    SELECT COUNT(*) INTO v_active
    FROM public.tenant_members
    WHERE tenant_id = NEW.tenant_id
      AND status = 'active';
  END IF;
  
  IF NEW.status = 'active' AND v_active >= v_limit THEN
    RAISE EXCEPTION 'Seat limit reached for tenant %, limit=%', NEW.tenant_id, v_limit;
  END IF;
  
  RETURN NEW;
END 
$$;
CREATE FUNCTION "public"."escalate_conversation"(IN p_tenant UUID, IN p_conversation UUID, IN p_reason TEXT, IN p_payload JSONB, IN p_by_user UUID) RETURNS VOID LANGUAGE PLPGSQL
AS
$$

BEGIN
  UPDATE conversations
  SET status = 'needs_human',
      escalated_at = COALESCE(escalated_at, now())
  WHERE id = p_conversation AND tenant_id = p_tenant;

  INSERT INTO conversation_events (tenant_id, conversation_id, event_type, reason, payload, created_by_user_id)
  VALUES (p_tenant, p_conversation, 'escalated', p_reason, p_payload, p_by_user);
END 
$$;
CREATE FUNCTION "public"."gen_random_bytes"() RETURNS BYTEA LANGUAGE C
AS
$$
pg_random_bytes
$$;
CREATE FUNCTION "public"."gen_random_uuid"() RETURNS UUID LANGUAGE C
AS
$$
pg_random_uuid
$$;
CREATE FUNCTION "public"."gen_salt"() RETURNS TEXT|TEXT LANGUAGE C
AS
$$
pg_gen_salt_rounds
$$;
CREATE FUNCTION "public"."get_or_create_conversation"(IN p_tenant UUID, IN p_contact_id UUID, IN p_contact UUID, IN p_tenant_id INTEGER, IN p_channel TEXT, IN p_channel VARCHAR, IN p_bot_number VARCHAR) RETURNS UUID|UUID LANGUAGE PLPGSQL
AS
$$

DECLARE
  v_conversation_id UUID;
BEGIN
  SELECT id INTO v_conversation_id
  FROM conversations
  WHERE contact_id = p_contact_id
    AND status != 'closed'
    AND channel = p_channel
  ORDER BY created_at DESC
  LIMIT 1;
  
  IF v_conversation_id IS NULL THEN
    INSERT INTO conversations (contact_id, tenant_id, channel, bot_number, status)
    VALUES (p_contact_id, p_tenant_id, p_channel, p_bot_number, 'open')
    RETURNING id INTO v_conversation_id;
  END IF;
  
  RETURN v_conversation_id;
END;

$$;
CREATE FUNCTION "public"."hmac"() RETURNS BYTEA|BYTEA LANGUAGE C
AS
$$
pg_hmac
$$;
CREATE FUNCTION "public"."log_message"(IN p_tenant UUID, IN p_conversation UUID, IN p_sender USER-DEFINED, IN p_message_type USER-DEFINED, IN p_body TEXT, IN p_external_id TEXT, IN p_sender_user UUID, IN p_meta JSONB) RETURNS UUID LANGUAGE PLPGSQL
AS
$$

DECLARE
  v_message_id uuid;
BEGIN
  INSERT INTO messages (tenant_id, conversation_id, sender, sender_user_id, message_type, body, external_message_id, meta)
  VALUES (p_tenant, p_conversation, p_sender, p_sender_user, p_message_type, p_body, p_external_id, p_meta)
  ON CONFLICT (tenant_id, external_message_id)
  DO UPDATE SET meta = EXCLUDED.meta
  RETURNING id INTO v_message_id;

  UPDATE conversations
  SET last_message_at = now()
  WHERE id = p_conversation;

  RETURN v_message_id;
END 
$$;
CREATE FUNCTION "public"."pgp_armor_headers"(OUT key TEXT, OUT value TEXT) RETURNS RECORD LANGUAGE C
AS
$$
pgp_armor_headers
$$;
CREATE FUNCTION "public"."pgp_key_id"() RETURNS TEXT LANGUAGE C
AS
$$
pgp_key_id_w
$$;
CREATE FUNCTION "public"."pgp_pub_decrypt"() RETURNS TEXT|TEXT|TEXT LANGUAGE C
AS
$$
pgp_pub_decrypt_text
$$;
CREATE FUNCTION "public"."pgp_pub_decrypt_bytea"() RETURNS BYTEA|BYTEA|BYTEA LANGUAGE C
AS
$$
pgp_pub_decrypt_bytea
$$;
CREATE FUNCTION "public"."pgp_pub_encrypt"() RETURNS BYTEA|BYTEA LANGUAGE C
AS
$$
pgp_pub_encrypt_text
$$;
CREATE FUNCTION "public"."pgp_pub_encrypt_bytea"() RETURNS BYTEA|BYTEA LANGUAGE C
AS
$$
pgp_pub_encrypt_bytea
$$;
CREATE FUNCTION "public"."pgp_sym_decrypt"() RETURNS TEXT|TEXT LANGUAGE C
AS
$$
pgp_sym_decrypt_text
$$;
CREATE FUNCTION "public"."pgp_sym_decrypt_bytea"() RETURNS BYTEA|BYTEA LANGUAGE C
AS
$$
pgp_sym_decrypt_bytea
$$;
CREATE FUNCTION "public"."pgp_sym_encrypt"() RETURNS BYTEA|BYTEA LANGUAGE C
AS
$$
pgp_sym_encrypt_text
$$;
CREATE FUNCTION "public"."pgp_sym_encrypt_bytea"() RETURNS BYTEA|BYTEA LANGUAGE C
AS
$$
pgp_sym_encrypt_bytea
$$;
CREATE FUNCTION "public"."set_updated_at"() RETURNS TRIGGER LANGUAGE PLPGSQL
AS
$$

BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END 
$$;
CREATE FUNCTION "public"."update_updated_at_column"() RETURNS TRIGGER LANGUAGE PLPGSQL
AS
$$

BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;

$$;
CREATE FUNCTION "public"."upsert_contact_by_identifier"(IN p_tenant UUID, IN p_tenant_id INTEGER, IN p_channel VARCHAR, IN p_kind TEXT, IN p_value TEXT, IN p_identifier VARCHAR, IN p_name VARCHAR, IN p_push_name TEXT, IN p_metadata JSONB) RETURNS UUID|UUID LANGUAGE PLPGSQL
AS
$$

DECLARE
  v_contact_id uuid;
BEGIN
  SELECT contact_id INTO v_contact_id
  FROM contact_identifiers
  WHERE tenant_id = p_tenant AND kind = p_kind AND value = p_value;

  IF v_contact_id IS NULL THEN
    INSERT INTO contacts (tenant_id, push_name)
    VALUES (p_tenant, p_push_name)
    RETURNING id INTO v_contact_id;

    INSERT INTO contact_identifiers (tenant_id, contact_id, kind, value, is_primary, active)
    VALUES (p_tenant, v_contact_id, p_kind, p_value, true, true);
  ELSE
    -- update push_name kalau ada
    UPDATE contacts
    SET push_name = COALESCE(p_push_name, push_name)
    WHERE id = v_contact_id;
  END IF;

  RETURN v_contact_id;
END 
$$;
CREATE VIEW "public"."v_conversation_inbox"
AS
 SELECT c.id AS conversation_id,
    c.tenant_id,
    c.status,
    c.assigned_user_id,
    c.escalated_at,
    c.last_message_at,
    ct.id AS contact_id,
    COALESCE(ct.display_name, ct.push_name) AS contact_name,
    ci.value AS primary_identifier
   FROM ((conversations c
     JOIN contacts ct ON ((ct.id = c.contact_id)))
     LEFT JOIN LATERAL ( SELECT ci_1.value
           FROM contact_identifiers ci_1
          WHERE ((ci_1.contact_id = ct.id) AND (ci_1.active = true))
          ORDER BY ci_1.is_primary DESC, ci_1.created_at DESC
         LIMIT 1) ci ON (true));;
CREATE VIEW "public"."v_escalation_queue"
AS
 SELECT conversation_id,
    tenant_id,
    status,
    assigned_user_id,
    escalated_at,
    last_message_at,
    contact_id,
    contact_name,
    primary_identifier
   FROM v_conversation_inbox
  WHERE ((status)::text = 'needs_human'::text)
  ORDER BY escalated_at DESC NULLS LAST, last_message_at DESC;;
